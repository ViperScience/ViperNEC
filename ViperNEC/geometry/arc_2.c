//
//  arc_2.c
//  ViperNEC
//
//  Created by Dylan Crocker on 7/21/14.
//  Copyright 2014 Viper Science
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#include "blocks.h"
#include "error.h"
#include "macro.h"

#include <stdlib.h>
#include <math.h>

// The code uses these arrarys to store some other stuff temporarily.
#define x2 data->si
#define y2 data->alp
#define z2 data->bet

/**
 * This function (arc_2) is a cleaned up version of the function generated by
 * f2c (arc_) with some modifications. The main modification is the removal of
 * a global data structure containing all the buffers to hold the geometry data.
 * Instead, the data object (pointer) is passed as an input to the function.
 *
 * Original FORTRAN documentation:
 * ARC GENERATES SEGMENT GEOMETRY DATA FOR AN ARC OF NS SEGMENTS
 *
 * Original NEC Documentation:
 *
 * PURPOSE
 *     To fill COMMON/DATA with segment coordinates for a circular arc of
 * segments.
 *
 * METHOD
 *     The formal parameters specify the number of segments, radius of the arc,
 * starting angle, final angle and wire radius. Segment coordinates are computed
 * for the are in the x, a plane with a left hand rotation about the y axis.
 *
 * @param data NECDataBlock in which the parsed geometry data is stored. This
 * must not be NULL. The function will not execute if |data| is NULL.
 * @param itg The tag number assigned to each segment.
 * @param ns The number of segments.
 * @param rada arc radius
 * @param ang1 angle at first end
 * @param ang2 angle at second end
 * @param rad wire radius
 * @return Logical 1 if everything successful.
 * @since v1.0
 */
bool arc_2(NECDataBlock *data, int *itg, int *ns, double *rada,
           double *ang1, double *ang2, double *rad,
           NECError **error_block) {
  
  // Check the inputs.
  if (*ns < 1) { return true; /* No segments...*/ }
  if (data == NULL) {
    if (error_block != NULL) { *error_block = NECErrorMakeInvalidInput(); }
    return false;
  }
  
  // x coordinate of 2nd end of segment
  // z coordinate of 2nd end of segment
  double xs2, zs2;
  
  size_t index_start = data->n; // number of initial segment
  data->n += *ns; // Increase the wire segment count
  
  // Make sure the buffers are large enough.
  if (NECDataBlockEnlargeWireBuffers(data, data->n) == false) {
    if (error_block != NULL) { *error_block = NECErrorMakeOutOfMemeory(); }
    return false;
  }
  
  data->np = data->n;
  data->mp = data->m;
  data->ipsym = 0;
  
  if (fabs(*ang2 - *ang1) > 360.0) {
    // Error - Arc angle exceeds 360 degrees.
    // Maybe this should just coerce to 360??
    *error_block = NECErrorMake005();
    return false;
  }
  
  double ang = DEG_TO_RAD(*ang1); // angle of point on the arc (radians, zero on x axis)
  double dang = DEG_TO_RAD(*ang2 - *ang1)/(*ns); // angle covered by each segment
  double xs1 = *rada * cos(ang); // x coordinate of first end of segment
  double zs1 = *rada * sin(ang); // z coordinate of first end of segment
  
  for (size_t i__ = index_start; i__ < data->n; ++i__) {
    
    ang += dang;
    xs2 = *rada * cos(ang);
    zs2 = *rada * sin(ang);
    
    data->x[i__] = xs1;
    data->y[i__] = 0.0;
    data->z[i__] = zs1;
    x2[i__] = xs2;
    y2[i__] = 0.0;
    z2[i__] = zs2;
    
    xs1 = xs2;
    zs1 = zs2;
    
    data->bi[i__] = *rad;
    data->itag[i__] = *itg;
  }
  
  return true;
}

#undef x2
#undef y2
#undef z2
