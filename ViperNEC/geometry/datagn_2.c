//
//  datagn_2.c
//  ViperNEC
//
//  Created by Dylan Crocker on 7/15/14.
//  Copyright 2014 Viper Science
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "geometry.h"
#include "blocks.h"
#include "error.h"
#include "types.h"
#include "const.h"
#include "macro.h"
#include "cards.h"
#include "util.h"
#include "io.h"

#define CODE_LENGTH 2
#define START_BUFF_SIZE 10

/** <b>datagn_2<\b>
 * This function (datagn_2) is a cleaned up and modified version of the function
 * generated by f2c. Changes include the removal of dependence on global 
 * variables and the use of variable length data buffers instead of fixed 
 * arrays (with some max size). Currently the convoluted f2c file I/O is still 
 * used to write the output file.
 *
 * Original FORTRAN description:
 * DATAGN IS THE MAIN ROUTINE FOR INPUT OF GEOMETRY DATA.
 *
 * Origianl NEC Documentation:
 *
 * PURPOSE
 *     To read structure input data and set segment and patch data.
 *
 * METHOD
 *     The main READ statement is at DA35. The READ statement at DA65 is for the
 * continuation of wire data (GC card following GW), and the READ at DA133 is
 * for the continuation of surface patch data (SC following SP or SM). 
 *     The first input parameter GH determines the function of the card as
 * indicated in the following table:
 *
 *     <ul>GM    GO TO    FUNCTION<\ul>
 *     GA        8    define wire arc
 *     GC        6    continuation of wire data
 *     GE       29    end of geometry data
 *     GF       27    read NGF file
 *     GH       26    rotate or translate structure
 *     GR       19    rotate about Z axis (symmetry)
 *     GS       21    scale structure
 *     GW        3    define straight wire
 *     GX       18    reflect in coordinate planes (symmetry)
 *     SC       10    continuation of patch data
 *     SM       18    define multiple surface patches
 *     SP        9    define surface patch
 *
 *     The functions of the other input parameters depend on the type of data
 * card and can be determined from the data card descriptions in Part III of
 * this manual.
 *     Subroutines are called to perform many of the operations requested by
 * the data cards. Coding in DATAGN performs other operations, prints
 * information and checks for input errors. After a GE card is read subroutine
 * CONECT is called at DA21I to find electrical connections of segments. Segment
 * and patch data is printed from DA217 to DA256. Line DA241 tests for segmentg
 * of zero length (<10E-20) or zero radius (<10E-101).
 *
 * SYMBOL DICTIONARY
 *     Variables have multiple uses which depend on the type of input card
 * being processed.
 *
 * @param input NECInputFile object containing the data from the actual NEC
 *              input file. This input must not be NULL or else the function 
 *              immeadiatly returns.
 * @param data NECDataBlock in which the parsed geometry data is stored. If this
 *             input is NULL the function creates a new one and assigns it to 
 *             |data|.
 * @since v1.0
 */
void datagn_2(NECInputFile *input, NECDataBlock **data, NECAngleBlock **angl,
              NECPlotBlock **plot, NECCurrentExpansionBlock **segj,
              NECOutputFile **output_file, NECError **error) {
  
  // Make sure the input file has been parsed. We need data!!
  if (!input) {
    if (error) { *error = NECErrorMakeNoInputData(); }
    return;
  }
  
  // Make sure no NULL values were passed in for the required parameters (some
  // of the objects are required to be initialized prior to this function).
  if (data == NULL || angl == NULL || plot == NULL || output_file == NULL) {
    if (error) { *error = NECErrorMakeInvalidInput(); }
    return;
  }
  
  // Initialize the data storage blocks if needed.
  if (*data == NULL) {
    *data = NECDataBlockMake(START_BUFF_SIZE, START_BUFF_SIZE);
    if (*data == NULL) {
      if (error) { *error = NECErrorMakeOutOfMemeory(); }
      return;
    }
  }
  if (*angl == NULL) {
    *angl = NECAngleBlockMake(START_BUFF_SIZE, START_BUFF_SIZE);
    if (angl == NULL) {
      if (error) { *error = NECErrorMakeOutOfMemeory(); }
      return;
    }
  }
  if (*plot == NULL) {
    *plot = NECPlotBlockMake();
    if (*plot == NULL) {
      if (error != NULL) { *error = NECErrorMakeOutOfMemeory(); }
      return;
    }
  }
  if (*segj == NULL) {
    *segj = NECCurrentExpansionBlockMake();
    if (*segj == NULL) {
      if (error) { *error = NECErrorMakeOutOfMemeory(); }
      return;
    }
  }
  
  // Count the number of wires entered.
  size_t nwire = 0;
  
  // If the NGF file is used, these variables are used to save the current state
  // of the ipsym, np, and mp values in the data struct.
  size_t npsav = 0, mpsav = 0;
  int ipsav = 0;
  
  // Ground plane flag (should be read from the GE card).
  // 0: no ground, 1: use image currents, -1: do not use image currents.
  int gnd_flag = 0;
  
  // Print flag (I think this was added to I2 of the GE card to indicate
  // the currents, etc. were going to be printed to the plot data file).
  int plot_flag = 0;
  
  // Declare the variables used when reading the values from the cards.
  char code[CODE_LENGTH + 1];
  int cl = CODE_LENGTH;
  int i1 = 0, i2 = 0; // Integer values read from the geometry card.
  double f1, f2, f3, f4, f5, f6, f7; // Real values read from the geometry card.
  
  // This variable is used to index out cards (lines of text) from the array of
  // strings contained in the NECInputFile object.
  size_t card_index;
  
  // Array of strings which contain the textual data from the geometry cards
  // defined in the input file (from the NECInputFile object).
  char **cards = input->geometryCards;
  
  //////////////////////////////////////////////////////////////////////////////
  // READ GEOMETRY DATA CARD AND BRANCH TO SECTION FOR OPERATION REQUESTED
  //////////////////////////////////////////////////////////////////////////////
  
  // Loop through all the geometry cards and setup the simulation geometry.
  for (card_index = 0; card_index < input->geometryCardCount; ++card_index) {
    
    // Make sure shit isn't getting out of hand...
    if (((**data).n + (**data).m) > ((**data).ld + (**data).lp)) {
      if (error) { *error = NECErrorMake033(); }
      return;
    }
    
    // Parse the information from the geometry card.
    char *card = cards[card_index];
    readgm_2(card, code, cl, &i1, &i2, &f1, &f2, &f3, &f4, &f5, &f6, &f7);
    
    // Branch to the appropriate action for the given command.
    switch (label_id(code)) {
        
      //////////////////////////////////////////////////////////////////////////
      // This case handles wire data.
      //////////////////////////////////////////////////////////////////////////
      case CardLabel_GW: {
        ++nwire; // Count the wire.
        
        // Save the read data in more appropriately named variables.
        int tag = i1, num_segs = i2;
        double s1_x = f1, s1_y = f2, s1_z = f3; // start x, y, and z coordinates
        double s2_x = f4, s2_y = f5, s2_z = f6; // end x, y, and z coordinates
        double radius = f7; // wire radius
        
        // Calculate the start and stop segment based on exisitng segments.
        size_t star_seg = (**data).n + 1;  // wire start segment
        size_t stop_seg = (**data).n + i2; // wire stop segment
        
        // Default values (changed if a GC card is provided.
        double rdel = 1.0; // Segment length ratio
        double rrad = 1.0; // Segment radius ratio
        
        // Write the wire structure data to the output file.
        NECOutputFileWriteWireStructureSpec(
            *output_file, nwire, s1_x, s1_y, s1_z, s2_x, s2_y, s2_z, radius,
            num_segs, star_seg, stop_seg, tag);
        
        // If the radius is 0 there must be a GC card immeadiatly following.
        // Read the GC card and adjust the radius information.
        if (radius == 0.0) {
          
          // First make sure there is another card to read.
          if ((card_index + 1) >= input->geometryCardCount) {
            if (error) { *error = NECErrorMake019(); }
            return; // Quit the function if an error occurs.
          }
          
          // Variables to hold the data from the GC card.
          double rad1 = 0; // Radius of the first segment
          double rad2 = 0; // Radius of the last segment
          
          // Since the next card is being read here (within the for-loop),
          // manually increment the index.
          card_index++;
          
          // Get the next card from the array of geometry cards and parse it.
          card = cards[card_index];
          readgm_2(card, code, cl, &i1, &i2, &rdel, &rad1, &rad2, &f4, &f5,
                   &f6, &f7);
          
          if (label_id(code) == CardLabel_GC) { // if the card was in fact a GC
            
            // Ensure the values make sense.
            if (rad1 == 0.0 || rad2 == 0.0 || num_segs <= 1) {
              if (error) { *error = NECErrorMake019(); }
              return; // Quit the function if an error occurs.
            }
            
            // Log the data
            NECOutputFileWriteWireTapperData(*output_file, rdel, rad1, rad2);
            
            // Calculate the wire tapper.
            radius = rad1;
            rrad = pow(rad2/rad1, 1.0/(num_segs - 1.0));
            
          } else { // Error: rad == 0 but no GC card.
            if (error) { *error = NECErrorMake019(); }
            return; // Quit the function if an error occurs.
          }
        }
        
        // Call the wire function to fill the geometry buffer with the segments
        // specified by the wire card.
        if(!wire_2(*data, &s1_x, &s1_y, &s1_z, &s2_x, &s2_y, &s2_z,
                        &radius, &rdel, &rrad, &num_segs, &tag, error)) {
          return; // Quit the function if an error occurs.
        }
        
        break; // Read the next card.
      }
      
      //////////////////////////////////////////////////////////////////////////
      // Generate wire arc
      //////////////////////////////////////////////////////////////////////////
      case CardLabel_GA: {
        ++nwire;
        
        // Save the read data to more appropriately named variables.
        int tag = i1, num_segs = i2;
        double rada = f1; // arc radius
        double ang1 = f2; // angle of first end of the arc
        double ang2 = f3; // angle of the second end of the arc
        double rad = f4;  // wire radius
        
        size_t first_seg = (**data).n + 1;
        size_t last_seg  = (**data).n + num_segs;
        
        // Log the arc data to file.
        NECOutputFileWriteArcData(*output_file, nwire, rada, ang1, ang2, rad,
                                  num_segs, first_seg, last_seg, tag);
        
        // Call the arc function to fill the geometry buffer with the segments
        // specified by the arc card.
        if (!arc_2(*data, &tag, &num_segs, &rada, &ang1, &ang2, &rad, error)) {
          return; // Quit the function if an error occurs.
        }
        
        break; // Read the next card.
      }
        
      //////////////////////////////////////////////////////////////////////////
      // Generate helix data
      //////////////////////////////////////////////////////////////////////////
      case CardLabel_GH: {
        ++nwire;  // Count the wire.
        
        // Save the read data in more appropriately named variables.
        int tag = i1, num_segs = i2;
        double turns = f1; // number of turns in the spiral
        double zlen = f2;  // length of the spiral (along the z-axis)
        double hr1 = f3;   // radius of the spiral at the start
        double hr2 = f4;   // radius of the spiral at the end
        double wr1 = f5;   // Radius of wire at the first segment
        double wr2 = f6;   // Radius of wire at the last segment
        double ispx = f7;  // 0 - log spiral, 1 - archimedes (if hr1 != hr2)
        
        size_t first_seg = (**data).n + 1;
        size_t last__seg = (**data).n + num_segs;
        
        // Log the helix data
        NECOutputFileWriteHelixData(
            *output_file, turns, zlen, nwire, hr1, hr2, wr1, wr2, ispx,
            num_segs, first_seg, last__seg, tag);
        
        // Call the helix function to fill the geometry buffer with the segments
        // specified by the helix card.
        if (!helix_2(*data, &turns, &zlen, &hr1, &hr2, &wr1, &wr2, &ispx,
                     &num_segs, &tag, *output_file, error)) {
          return; // Quit the function if an error occurs.
        }
        
        break; // read the next card.
      }
        
      //////////////////////////////////////////////////////////////////////////
      // GENERATE SINGLE NEW PATCH
      //////////////////////////////////////////////////////////////////////////
      case CardLabel_SP: {
        
        // Use more descriptive variables.
        // Note: Ignore i1 (or the nx input), just set it to zero.
        int nx = 0;
        int ny = i2 + 1; // ny = ns + 1 (ns is i1 from the data card).
        double x1 = f1, y1 = f2, z1 = f3;
        double x2 = f4, y2 = f5, z2 = f6;
        double x3 = 0., y3 = 0., z3 = 0.; // (not yet set)
        double x4 = 0., y4 = 0., z4 = 0.; // (not yet set)
        size_t patch_num = (**data).m + 1;
        
        // Log the specification data to the output file.
        char type[4][5] = {"P   ", "R   ", "T   ", "Q   "};
        NECOutputFileWritePatchStructureSpec(
            *output_file, patch_num, &type[ny - 1][0], x1, y1, z1, x2, y2, z2);
        
        // If ny > 1, then the patch type is either rectangualr, triangular, or
        // quadrilateral and the subsequent card contains the rest of the
        // information.
        if (ny > 1) {
          
          // Make sure more cards exist...
          if ((card_index + 1) >= input->geometryCardCount) {
            if (error) { *error = NECErrorMake034(); }
            return; // Quit the function if an error occurs.
          }
          
          // Read the next card
          ++card_index;
          card = input->geometryCards[card_index];
          readgm_2(card, code, cl, &i1, &i2, &x3, &y3, &z3, &f4, &f5, &f6, &f7);
          
          // Make sure the next card was the correct type (an SC card which
          // contains the seconf half of the patch data).
          if (label_id(code) == CardLabel_SC) {
            
            // If it is a rectangle, claculate corner 4 from the other corners
            // before logging the data.
            if (ny == 2) {
              x4 = x1 + x3 - x2;
              y4 = y1 + y3 - y2;
              z4 = z1 + z3 - z2;
            }
            
            // Log the additional patch specification data.
            NECOutputFileWritePatchStructureSpecPart2(
                *output_file, x3, y3, z3, x4, y4, z4);
            
          } else {
            // If the SC card did not follow as expected, set the error block
            // and exit the function.
            if (error) { *error = NECErrorMake034(); }
            return;
          }
        } else {
          // For an arbitrary patch, the input to the card is in degrees but the
          // patch function wants radians (I don't know why they did it this
          // way...)
          x2 = DEG_TO_RAD(x2);
          y2 = DEG_TO_RAD(y2);
        }
          
        // Call the patch_2 function to generate the specified geometry and
        // check for errors when the function returns.
        if (!patch_2(*data, *angl, &nx, &ny, &x1, &y1, &z1, &x2, &y2, &z2,
                     &x3, &y3,&z3, &x4, &y4, &z4, error)) {
          return; // Quit the function if an error occurs.
        }
        
        break; // read the next card...
      }
       
      //////////////////////////////////////////////////////////////////////////
      // GENERATE MULTIPLE-PATCH SURFACE
      //////////////////////////////////////////////////////////////////////////
      case CardLabel_SM: {
        
        // Use this fag to signal an error so the error block can be set.
        bool error_flag = false;
        
        // Use more variable names consistent with card inputs.
        int nx = i1, ny = i2;
        double x1 = f1, y1 = f2, z1 = f3; // Corner 1 coordinates
        double x2 = f4, y2 = f5, z2 = f6; // Corner 2 coordinates
        double x3 = 0., y3 = 0., z3 = 0.; // Corner 3 coordinates (unknown)
        double x4 = 0., y4 = 0., z4 = 0.; // Corner 4 coordinates (unknown)
        
        // Log the multiple patch specification data to the output file.
        size_t patch_num = (**data).m + 1;
        NECOutputFileWriteMultiPatchSpecP1(
            *output_file, patch_num, x1, y1, z1, x2, y2, z2, nx, ny);
        
        // Check the input parameters.
        if (nx > 0 && ny > 0) {
          
          // Make sure more cards exist as there should be another data card
          // with subsequent information about the patch in an SC card.
          if ((card_index + 1) >= input->geometryCardCount) {
            if (error) { *error = NECErrorMake034(); }
            return; // Quit the function if an error occurs.
          }
          
          // Read the next card (should be an SC card).
          ++card_index;
          card = input->geometryCards[card_index];
          readgm_2(card, code, cl, &i1, &i2, &x3, &y3, &z3, &f4, &f5, &f6, &f7);
          
          // Make sure the next card was the correct type (an SC card which
          // contains the seconf half of the multiple patch data).
          if (label_id(code) == CardLabel_SC) {
            
            // Calculate the coordinates of corner #4 from the coordinates of
            // the other corners before logging the data.
            x4 = x1 + x3 - x2;
            y4 = y1 + y3 - y2;
            z4 = z1 + z3 - z2;

            // Log the additional multiple patch specification data.
            NECOutputFileWriteMultiPatchSpecP2(
                *output_file, x3, y3, z3, x4, y4, z4);

            if(!patch_2(*data, *angl, &nx, &ny, &x1, &y1, &z1, &x2, &y2,
                        &z2, &x3, &y3, &z3, &x4, &y4, &z4, error)) {
              return; // Quit the function if an error occurs.
            }
            
          } else {
            // SC card not found...
            error_flag = true;
          }
        } else {
          // nx or ny was not greater than zero...
          error_flag = true;
        }
        
        // Patch data error.
        if (error_flag) {
          if (error != NULL) { *error = NECErrorMake034(); }
          return;
        }
        
        break; // read the next card...
      }
        
      //////////////////////////////////////////////////////////////////////////
      // Scale structure dimensions.
      //////////////////////////////////////////////////////////////////////////
      case CardLabel_GS: {

        // Scale the wire segment data.
        if ((**data).n > (**data).n1) {
          for (size_t i = (**data).n1; i < (**data).n; ++i) {
            (**data).x[i]   *= f1;
            (**data).y[i]   *= f1;
            (**data).z[i]   *= f1;
            (**data).si[i]  *= f1; // x2
            (**data).alp[i] *= f1; // y2
            (**data).bet[i] *= f1; // z2
            (**data).bi[i]  *= f1;
          }
        }
        
        // Scale the surface patch data.
        if ((**data).m > (**data).m1) {
          for (size_t i = (**data).m1; i < (**data).m; ++i) {
            (**data).xp[i] *= f1;
            (**data).yp[i] *= f1;
            (**data).zp[i] *= f1;
            (**data).pa[i] *= (f1 * f1);
          }
        }
        
        // Update the log file.
        NECOutputFileWriteScaleStructure(*output_file, f1);
        
        break;  // Read the next card.
      }
        
      //////////////////////////////////////////////////////////////////////////
      // REFLECT STRUCTURE ALONG X,Y, OR Z AXES
      //////////////////////////////////////////////////////////////////////////
      case CardLabel_GX: {
        
        // Name variables consistent with the GX card documentation.
        int itx = i1; // The segment tag increment
        int nop = 0.; // Not actually used (only used for GR)
        
        // The rotation flags are combined into one integer. The x flag is in
        // the hundreds place, the y flag is in the tens place and the z flag is
        // in the ones place.
        int ix = (i2 & 100)/100;
        int iy = (i2 & 10)/10;
        int iz = (i2 & 1);
        
        // Just in case there was a value not 1 or 0.
        if (ix != 0) {
          ix = 1;
        }
        if (iy != 0) {
          iy = 1;
        }
        if (iz != 0) {
          iz = 1;
        }

        // Log the reflection specification data
        NECOutputFileWriteReflectionData(*output_file, ix, iy, iz, itx);
        
        // Call reflec_2 to generate the reflected geometry data in the geometry
        // data buffers.
        if (!reflc_2(*data, *angl, &ix, &iy, &iz, &itx, &nop, error)) {
          return; // Quit the function if an error occurs.
        }
        
        break; // Read the next card.
      }

      //////////////////////////////////////////////////////////////////////////
      // ROTATE TO FORM CYLINDER.
      //////////////////////////////////////////////////////////////////////////
      case CardLabel_GR: {
        
        // Rotate along the x-axis to form a cylinder.
        int ix = -1, iy = 0, iz = 0;
        
        // Total number of times that the structure is to occur in the
        // cylindrical array
        int ns = i2;
        
        // Tag number of the structure to be rotated
        int itg = i1;
        
        // Update the logfile
        NECOutputFileWriteZAxisRotation(*output_file, itg, ns);
        
        // Call reflec_2 to execute the structure rotation in the data arrays.
        if (!reflc_2(*data, *angl, &ix, &iy, &iz, &itg, &ns, error)) {
          return; // Quit the function if an error occurs.
        }
        
        break; // Read the next card.
      }
        
      //////////////////////////////////////////////////////////////////////////
      // MOVE STRUCTURE OR REPRODUCE ORIGINAL STRUCTURE IN NEW POSITIONS.
      //////////////////////////////////////////////////////////////////////////
      case CardLabel_GM: {
        
        // Save the read data to more appropriately named variables.
        double arx = DEG_TO_RAD(f1); // The angle of rotation about the x-axis
        double ary = DEG_TO_RAD(f2); // The angle of rotation about the y-axis
        double arz = DEG_TO_RAD(f3); // The angle of rotation about the z-axis
        double xdt = f4; // X direction translation variable
        double ydt = f5; // Y direction translation variable
        double zdt = f6; // Z direction translation variable
        int tag = (int) (f7 + 0.5); // The tag of first segment to be moved
        int reps = i2; // Repetition factor
        int tagi = i1; // Tag increment
        
        // Write the info to the log file.
        NECOutputFileWriteStructureMoved(
            *output_file, tagi, reps, arx, ary, arz, xdt, ydt, zdt, tag);
        
        // Call move_2 to execute the structure move in the data arrays.
        if(!move_2(*data, *angl, &arx, &ary, &arz, &xdt, &ydt, &zdt, &tag,
                   &reps, &tagi, error)) {
          return; // Quit the function if an error occurs.
        }
        
        break; // Read the next card.
      }
        
      //////////////////////////////////////////////////////////////////////////
      // Numerical Green's function.
      //////////////////////////////////////////////////////////////////////////
      case CardLabel_GF: {
        
        // TO-DO
        // Update the code so this error doesn't happen. The code should be able
        // to shift the data already in the buffers forward if need be.
        if ((**data).n + (**data).m != 0) {
          // The GF card must be the first geometry card since it contains the
          // geometry data that must be at the begining of the data buffers.
          if (error) { *error = NECErrorMake010(); }
          return;
        }
        
        // Read the N.G.F. file and fill the data arrays.
//        if (!gfil_2()) {
//          return;
//        }
        
        // Save the data in temporary variables.
        npsav = (**data).np;
        mpsav = (**data).mp;
        ipsav = (**data).ipsym;
        
        break; // Read the next line.
      }
      
      //////////////////////////////////////////////////////////////////////////
      // End of geometry input.
      //////////////////////////////////////////////////////////////////////////
      case CardLabel_GE: {
        // This is the end of geometry input. End the loop and use the info from
        // the GE card if it exists.
        if (!((card_index + 1) >= input->geometryCardCount)) {
          card_index = input->geometryCardCount;
        }
        gnd_flag = i1;  // Set the ground flag which is part of the GE card.
        plot_flag = i2; // Set the print flag for the plot data file.
        break; // Break to the post processing part
      }
        
      //////////////////////////////////////////////////////////////////////////
      // If an unknown card is read (should not happen with new code).
      //////////////////////////////////////////////////////////////////////////
      default: {
        // Write the data from the erroneous input card to the log file.
        NECOutputFileWriteGeometryCardError(
            *output_file, code, i1, i2, f1, f2, f3, f4, f5, f6, f7);
        if (error) { *error = NECErrorMake019(); }
        return;
      }
        
    } // end card label switch
  } // end read data card loop
  
  //////////////////////////////////////////////////////////////////////////////
  // TERMINATE STRUCTURE GEOMETRY INPUT.
  //////////////////////////////////////////////////////////////////////////////
  
  // Set the flags for the plot data file.
  if (plot_flag != 0) {
    (**plot).iplp1 = 1;
    (**plot).iplp2 = 1;
  }
  
  // Count the number of wire segments and patches read from the N.G.F. file.
  size_t npm = (**data).n1 + (**data).m1;
  
  // If the N.G.F. was used, clear all symetry before running connect_2 (I'm not
  // sure why we do this...).
  if (npm != 0) {
	(**data).np = (**data).n;
    (**data).mp = (**data).m;
    (**data).ipsym = 0;
  }
  
  // Go through the geometry data and make connections between sgements and
  // patches. Quit the function on error.
  if (!connect_2(*data, *segj, *angl, &gnd_flag, *output_file, error)) {
    return; // Quit the function if an error occurs.
  }
  
  // Put the symetry back.
  if (npm != 0) {
    (**data).np = npsav;
    (**data).mp = mpsav;
    (**data).ipsym = ipsav;
  }
  
  // Make sure the data is not outside the limits (should never happen with the
  // new architecture - remove?)
  if (((**data).n > (**data).ld) || ((**data).m > (**data).lp)) {
    if (error) { *error = NECErrorMake033(); }
  }
  
  // Go through the wire segment data and adjust the data (instead of storing
  // two end points, calculate the center, etc.). See the documentation in
  // NECDataBlock.h.
  if ((**data).n != 0) {
    
    NECOutputFileWriteWireSementationHeader(*output_file);
    
    // The code uses these arrarys to store some other stuff temporarily. See
    // the documentation in NECDataBlock.h. This data is saved here and then
    // overwritten.
    double *x2 = (**data).si;
    double *y2 = (**data).alp;
    double *z2 = (**data).bet;
    
    // Alias the code uses to fill these arrays here.
    double *cab = ((**data).alp);
    double *sab = ((**data).bet);
    
    // Make sure the alpha angle buffer is the same size as the number of wires.
    if (!NECAngleBlockEnlargeWireBuffer(*angl, (**data).n)) {
      if (error) { *error = NECErrorMakeOutOfMemeory(); }
      return;
    }
    
    // Go through the wire segment data and adjust the data. See the
    // documentation in NECDataBlock.h.
    for (size_t i = 0; i < (**data).n; ++i) {
      
      // Save delta x, y, and z for the segment.
      double dx = x2[i] - (**data).x[i];
      double dy = y2[i] - (**data).y[i];
      double dz = z2[i] - (**data).z[i];
      
      // Shift the x, y, z data to represent the coordinate in the middle of the
      // segment instead of one end.
      (**data).x[i] = ((**data).x[i] + x2[i]) / 2;
      (**data).y[i] = ((**data).y[i] + y2[i]) / 2;
      (**data).z[i] = ((**data).z[i] + z2[i]) / 2;
      
      // Calculate the length of the segment.
      (**data).si[i] = sqrt(dx * dx + dy * dy + dz * dz);
      
      // See documentation for NECDataBlock
      cab[i] = dx / (**data).si[i]; // cos(alpha)*cos(beta) = dx/si
      sab[i] = dy / (**data).si[i]; // cos(alpha)*sin(beta) = dy/si
      
      // See documentation for NECAngleBlock
      double sina = dz / (**data).si[i]; // sin(alpha) = dz/si
      if (sina >  1.0) { sina =  1.0; }
      if (sina < -1.0) { sina = -1.0; }
      (**angl).alpha[i] = sina;
      
      // Get alpha and beta in degrees for storing to file (easier to read?).
      double alpha_deg = RAD_TO_DEG(asin(sina));
      double beta_deg = RAD_TO_DEG(atgn2_(&dy, &dx));
      
      NECOutputFileWriteWireSementationData(
          *output_file, IDX_TO_NUM(i), (**data).x[i], (**data).y[i],
          (**data).z[i], (**data).si[i], alpha_deg, beta_deg, (**data).bi[i],
          (**data).icon1[i], (**data).icon2[i], (**data).itag[i]);

// TO-DO: Fix this... lol
//      if ((**plot).iplp1 == 1) {
//        /*********** Warning: Atrocious f2c file IO below - REPLACE ***********/
//        integer c__5 = 5, c__3 = 3;
//        cilist io___550 = {0, 8, 0, 0, 0};
//        s_wsle(&io___550);
//        do_lio(&c__5, &c__1, (char *)&(**data).x[i__ - 1], (ftnlen)sizeof(double));
//        do_lio(&c__5, &c__1, (char *)&(**data).y[i__ - 1], (ftnlen)sizeof(double));
//        do_lio(&c__5, &c__1, (char *)&(**data).z[i__ - 1], (ftnlen)sizeof(double));
//        do_lio(&c__5, &c__1, (char *)&(**data).si[i__ - 1], (ftnlen)sizeof(double));
//        do_lio(&c__5, &c__1, (char *)&alpha_deg, (ftnlen)sizeof(double));
//        do_lio(&c__5, &c__1, (char *)&beta_deg, (ftnlen)sizeof(double));
//        do_lio(&c__5, &c__1, (char *)&(**data).bi[i__ - 1], (ftnlen)sizeof(double));
//        do_lio(&c__3, &c__1, (char *)&(**data).icon1[i__ - 1], (ftnlen)sizeof(integer));
//        do_lio(&c__3, &c__1, (char *)&i__, (ftnlen)sizeof(integer));
//        do_lio(&c__3, &c__1, (char *)&(**data).icon2[i__ - 1], (ftnlen)sizeof(integer));
//        e_wsle();
//      }
    
      // Check that the wire segment length and radius are both acceptable.
      if (!((**data).si[i] > NEC_MIN_WIRE_LENGTH &&
            (**data).bi[i] > NEC_MIN_WIRE_RADIUS)) {
        *error = NECErrorMake040();
        return;
      }
      
    } // End looping through wire segment data.
  } // End wire segment data processing
  
  
  // Go through the surface patch data and print it to the output file.
  if ((**data).m != 0) {
    
    NECOutputFileWritePatchDataHeader(*output_file);
    
    // Define some local pointers to the data for code readability.
    double *xp = (**data).xp;
    double *yp = (**data).yp;
    double *zp = (**data).zp;
    double *pa = (**data).pa;
    double *t1x = (**data).t1x;
    double *t1y = (**data).t1y;
    double *t1z = (**data).t1z;
    double *t2x = (**data).t2x;
    double *t2y = (**data).t2y;
    double *t2z = (**data).t2z;
    
    // Loop through the patch data.
    for (size_t j = 0; j < (**data).m; ++j) {
      
      double xw1, yw1, zw1;
      xw1 = (t1y[j] * t2z[j] - t1z[j] * t2y[j]) * (**angl).salp[j];
      yw1 = (t1z[j] * t2x[j] - t1x[j] * t2z[j]) * (**angl).salp[j];
      zw1 = (t1x[j] * t2y[j] - t1y[j] * t2x[j]) * (**angl).salp[j];
      
      NECOutputFileWritePatchData(
          *output_file, j, xp[j], yp[j], zp[j], xw1, yw1, zw1, pa[j],
          t1x[j], t1y[j], t1z[j], t2x[j], t2y[j], t2z[j]);
      
    } // End looping through patch data.
  } // End patch data processing.
  
  // Clean up (make sure it is ok to clean this up here).
  free(input->geometryCards);
  input->geometryCards = NULL;
  input->cardCount -= input->geometryCardCount;
  input->geometryCardCount = 0;
  
} // end datagn_2
