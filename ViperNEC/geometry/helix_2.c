//
//  helix_2.c
//  ViperNEC
//
//  Created by Dylan Crocker on 7/20/14.
//  Copyright 2014 Viper Science
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#include "blocks.h"
#include "error.h"
#include "macro.h"
#include "io.h"

#include <math.h>

// The code uses these arrarys to store some other stuff temporarily.
#define x2 data->si
#define y2 data->alp
#define z2 data->bet

/**
 *  This function (helix_2) is a cleaned up version of the function generated by
 *  f2c (helix_) with some modifications. The main modification is the removal
 *  of a global data structure containing all the buffers to hold the geometry
 *  data. Instead, the data object (pointer) is passed as an input to the
 *  function.
 *
 *  Original FORTRAN documentation:
 *  SUBROUTINE HELIX GENERATES SEGMENT GEOMETRY DATA FOR A HELIX OF NS SEGMENTS
 *
 *  @param data    NECDataBlock in which the parsed geometry data is stored
 *  @param s       <#s description#>
 *  @param hl      <#hl description#>
 *  @param a1      <#a1 description#>
 *  @param b1      <#b1 description#>
 *  @param a2      <#a2 description#>
 *  @param b2      <#b2 description#>
 *  @param rad     <#rad description#>
 *  @param ns      The number of segments
 *  @param itg     The tag number assigned to each segment
 *  @param outfile The output file object which facilitates data logging
 *  @param error   NECError block (pointer to a pointer) to hold error info
 *
 *  @return Returns TRUE if helical wire data successfully put into buffers.
 *
 *  @since v1.0
 */
bool helix_2(NECDataBlock *data, double *s, double *hl, double *a1, double *b1,
             double *a2, double *b2, double *rad, int *ns, int *itg,
             NECOutputFile *outfile, NECError **error) {

  // Check the function inputs...
  if (data == NULL) {
    if (error) { *error = NECErrorMakeInvalidInput(); }
    return false;
  }
  if (*ns < 1) { return true; /* No segments?? */ }
  
  // Local variables
  double hdia, hmaj, hmin, pitch, sangle, turn;
  long index_start = data->n; // number of initial segment
  
  data->n += *ns; // Update the count of wire segments.
  data->np = data->n;
  data->mp = data->m;
  data->ipsym = 0;
  
  // doublereal turns = abs((*hl)/(*s)); // <- Unused??
  double zinc = fabs((*hl)/(*ns));
  
  // Increase the buffer size if necessary
  if (NECDataBlockEnlargeWireBuffers(data, data->n) == false) {
    if (error) { *error = NECErrorMakeOutOfMemeory(); }
    return false;
  }
  
  data->z[index_start] = 0.0;
  for (long i__ = index_start; i__ < data->n; ++i__) {
    
    data->bi[i__] = *rad;
    data->itag[i__] = *itg;
    
    if (i__ != index_start) { data->z[i__] += zinc; } // zero to start
    
    z2[i__] = data->z[i__] + zinc;
    
    if (*a2 != *a1) {
      if (*b2 == 0.) { *b2 = *a2; }
      data->x[i__] = (*a1 + (*a2 - *a1) * data->z[i__] / fabs(*hl)) * cos(M_PI * 2.f * data->z[i__] / *s);
      data->y[i__] = (*b1 + (*b2 - *b1) * data->z[i__] / fabs(*hl)) * sin(M_PI * 2.f * data->z[i__] / *s);
      x2[i__] = (*a1 + (*a2 - *a1) * z2[i__] / fabs(*hl)) * cos(M_PI * 2.f * z2[i__] / *s);
      y2[i__] = (*b1 + (*b2 - *b1) * z2[i__] / fabs(*hl)) * sin(M_PI * 2.f * z2[i__] / *s);
    } else {
      if (*b1 == 0.) { *b1 = *a1; }
      data->x[i__] = *a1 * cos(M_PI * 2.f * data->z[i__] / *s);
      data->y[i__] = *b1 * sin(M_PI * 2.f * data->z[i__] / *s);
      x2[i__] = *a1 * cos(M_PI * 2.f * z2[i__] / *s);
      y2[i__] = *b1 * sin(M_PI * 2.f * z2[i__] / *s);
    }
    
    if (*hl > 0.) { continue;}
    
    double copy = data->x[i__];
    data->x[i__] = data->y[i__];
    data->y[i__] = copy;
    copy = x2[i__];
    x2[i__] = y2[i__];
    y2[i__] = copy;
  }
  
  if (*a2 != *a1) {
    sangle = atan((*a2)/(fabs(*hl) + fabs(*hl)*(*a1)/(*a2 - *a1)));
    if (outfile) { NECOutputFileWriteConeAngle(outfile, sangle); }
    return true;
  }

  if (*a1 != *b1) {
    if (*a1 < *b1) {
      hmaj = *b1 * 2.f;
      hmin = *a1 * 2.f;
    } else {
      hmaj = *a1 * 2.f;
      hmin = *b1 * 2.f;
    }
    hdia = sqrt((hmaj*hmaj + hmin*hmin)/2*hmaj);
    turn = M_PI*2.0*hdia;
    pitch = RAD_TO_DEG(atan((*s)/(M_PI*hdia)));
  } else {
    hdia = (*a1)*2.0;
    pitch = atan((*s)/(M_PI*hdia));
    turn  = (hdia * M_PI) / cos(pitch);
    pitch = RAD_TO_DEG(pitch);
  }
  
  if (outfile) {
    NECOutputFileWritePitchAngle(outfile, pitch);
    NECOutputFileWriteWireTurnLength(outfile, turn);
  }
  
  return true;
}

#undef x2
#undef y2
#undef z2
