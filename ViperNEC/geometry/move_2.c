//
//  move_2.c
//  ViperNEC
//
//  Created by Dylan Crocker on 7/26/14.
//  Copyright 2014 Viper Science
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#include "geometry.h"
#include "blocks.h"
#include "error.h"
#include "macro.h"

#include <math.h>

#define data_1 (*data) /* I don't like these... */
#define x (data_1.x)
#define y (data_1.y)
#define z (data_1.z)
#define xp (data->xp)
#define yp (data->yp)
#define zp (data->zp)
#define bi (data_1.bi)
#define pa (data_1.pa)
#define itag (data_1.itag)
#define ld (data_1.ld)
#define n1 (data_1.n1)
#define n2 (data_1.n2)
#define n (data_1.n)
#define np (data_1.np)
#define m1 (data_1.m1)
#define m2 (data_1.m2)
#define m (data_1.m)
#define mp (data_1.mp)
#define ipsym (data_1.ipsym)
#define salp (angl->salp)
#define x2 (data->si)
#define y2 (data->alp)
#define z2 (data->bet)
#define t1x (data->t1x)
#define t1y (data->t1y)
#define t1z (data->t1z)
#define t2x (data->t2x)
#define t2y (data->t2y)
#define t2z (data->t2z)

/**
 * This function (move_2) is a cleaned up version of the function generated by
 * f2c (move_) with some modifications. The main modification is the removal of
 * a global data structure containing all the buffers to hold the geometry data.
 * Instead, the data object (pointer) is passed as an input to the function.
 * Additionally, vector
 *
 * Original FORTRAN documentation:
 *     SUBROUTINE MOVE MOVES THE STRUCTURE WITH RESPECT TO ITS
 *     COORDINATE SYSTEM OR REPRODUCES STRUCTURE IN NEW POSITIONS.
 *     STRUCTURE IS ROTATED ABOUT X,Y,Z AXES BY ROX,ROY,ROZ
 *     RESPECTIVELY, THEN SHIFTED BY XS,YS,ZS
 *
 * Original NEC Documentation:
 *
 * PURPOSE
 *     To rotate and translate a previously defined structure, either moving
 * original segments and patches or leaving the original fixed and producing new
 * segments and patches.
 *
 * METHOD
 *     The formal parameters ROX, ROY, ROZ are the angles of rotation about
 * the x, y, and z axes, respectively, and XS, YS, ZS are the translation 
 * distance in the x, y, and z directions. Angles are in radians, and a positive
 * angle represents a right-hand rotation. The structure is first rotated about
 * the x axis by ROX, then about the y axis by ROY, then about the a axis by 
 * ROZ, and finally translated by XS, YS, ZS. These operations transform a point
 * with coordinates x, y, z to x', y', z', where
 *
 *     |x'|   |T11 T12 T13||x|   |xs|
 *     |y'| = |T21 T22 T23||y| + |ys|
 *     |z'|   |T31 T32 T33||z|   |zs|
 *
 * where
 *
 *     T11 = cos(phi)*cos(theta)
 *     T12 = cos(phi)*sin(theta)*sin(si) - sin(phi)*cos(si)
 *     T13 = cos(phi)*sin(theta)*cos(si) + sin(phi)*sin(si)
 *     T21 = sin(phi)*cos(theta)
 *     T22 = sin(phi)*sin(theta)*sin(si) + cos(phi)*cos(si)
 *     T23 = sin(phi)*sin(theta)*cos(si) - cos(phi)*sin(si)
 *     T31 = -sin(theta)
 *     T32 = cos(theta)*sin(si)
 *     T33 = cos(theta)*cos(si)
 *
 * with
 *
 *     si    = ROX
 *     theta = ROY
 *     phi   = ROZ
 *     Xs    = XS
 *     Ys    = YS
 *     Zs    = ZS
 *
 *     This transformation is applied to those wire segments from segment
 * number i_s to the last defined segment in COMMON/DATA/. Thus, if i_s is 
 * greater than 1, the segments from 1 to i_s - 1 are unaffected. All patches 
 * are transformed.
 *     NRPT is the structure repetition factor. If NRPT is zero, the transformed
 * segment and patch coordinates overwrite the original coordinates so that
 * the structure is moved with nothing left in the original location. If NRPT
 * is greater than zero, the transformed coordinates are written on the ends of
 * the arrays in COMMON/DATA/ and the process repeated NRPT times so that NRPT
 * new structures are formed, each shifted from the previous one by the 
 * specified transformation, while the original structure is unchanged.
 *
 * @param data NECDataBlock in which the parsed geometry data is stored. This
 * must not be NULL. The function will not execute if |data| is NULL.
 * @param angl
 * @param rox The angle of rotation about the x-axis.
 * @param roy The angle of rotation about the y-axis.
 * @param roz The angle of rotation about the z-axis.
 * @param xs X direction translation variable.
 * @param ys Y direction translation variable.
 * @param zs Z direction translation variable.
 * @param its The tag of the first wire segment in data to be moved.
 * @param nrpt Repetition factor.
 * @param itgi Increment applied to segment tag numbers as segments are 
 * transformed.
 * @param error_block NECError block (pointer to a pointer) to hold error info.
 * @since v1.0
 */
bool move_2(NECDataBlock *data, NECAngleBlock *angl, double *rox,
            double *roy, double *roz, double *xs, double *ys,
            double *zs, int *its, int *nrpt, int *itgi,
            NECError **error_block) {
 
  // Input verification
  if ((data == NULL) || (angl == NULL)) {
    if (error_block != NULL) { *error_block = NECErrorMakeInvalidInput(); }
    return false;
  }
  
  // Indexing variables.
  size_t k, i1;
  
  // Temp variables used to store the data to be translated.
  double xi, yi, zi;
  
  // Setting the symetry flag. I'm not sure how this works yet...
  if ((fabs(*rox) + fabs(*roy)) > 1e-10) {
    // If the struture is rotated about the x axis or the y axis, then set
    // |ipsym| > 2 (where ipsym is the symmetry flag).
	  ipsym *= 3; // What if ipsym = 0? Do we not want any symmetry then?
  }
  
  // Save these values so that the calculations are only performed once.
  double sps = sin(*rox);
  double cps = cos(*rox);
  double sth = sin(*roy);
  double cth = cos(*roy);
  double sph = sin(*roz);
  double cph = cos(*roz);
  
  // Build the translation matrix (elements).
  double T11 = cph * cth;
  double T12 = cph * sth * sps - sph * cps;
  double T13 = cph * sth * cps + sph * sps;
  double T21 = sph * cth;
  double T22 = sph * sth * sps + cph * cps;
  double T23 = sph * sth * cps - cph * sps;
  double T31 = -sth;
  double T32 = cth * sps;
  double T33 = cth * cps;
  
  // If no repeats are specified the loop must execute once.
  size_t nrp = (*nrpt <= 0) ? 1 : *nrpt; // loop count
  
  size_t ix = 0; // Index of first segment - initialize to zero
  
  // If there are more wire segments than those in the NGF file, proceed with
  // structure translation of the wire segments not in the NGF file.
  if (n > n1) {
	
    // Find the index of the first segment that needs moved.
    size_t i1 = isegno_2(data, *its, 1, error_block);
    if (error_block) {
      if ((**error_block).flag) {
        return false;
      }
    }
    
    i1 = NUM_TO_IDX(i1); // Change from seg no. to seg index.
    
    if (i1 < n1) { i1 = n1; } // Make sure its not in the NGF file.
    
    ix = i1; // Save the index for later...
    
    // If nrpt is zero the move replaces the old segment data in the arrays.
    // Otherwise, add to the segment data.
    if (*nrpt == 0) {
      k = i1;
    }
    else {
      k = n;
      if (!NECDataBlockEnlargeWireBuffers(data, n + *nrpt * (n - i1))) {
        if (error_block != NULL) { *error_block = NECErrorMakeOutOfMemeory(); }
        return false;
      }
    }
    
    for (size_t it = 0; it < nrp; ++it) {  // Loop for each translation
      for (size_t iw = i1; iw < n; ++iw) { // Loop for each wire segment
        
        // Save the data to be moved in a separate variable since they may be
        // over written below.
        xi = x[iw];
        yi = y[iw];
        zi = z[iw];
        
        // Perform the translation.
        x[k] = xi * T11 + yi * T12 + zi * T13 + (*xs);
        y[k] = xi * T21 + yi * T22 + zi * T23 + (*ys);
        z[k] = xi * T31 + yi * T32 + zi * T33 + (*zs);
        
        xi = x2[iw];
        yi = y2[iw];
        zi = z2[iw];
        
        x2[k] = xi * T11 + yi * T12 + zi * T13 + (*xs);
        y2[k] = xi * T21 + yi * T22 + zi * T23 + (*ys);
        z2[k] = xi * T31 + yi * T32 + zi * T33 + (*zs);
        
        bi[k] = bi[iw]; // wire radius doesn't change
        
        itag[k] = itag[iw];
        if (itag[iw] != 0) { itag[k] = itag[iw] + *itgi; }
        
        ++k;
      }
      i1 = n; // start of the last wire structure (index of first segment).
      n = k;  // end of the last wire structure (index of last segment).
    }
  }
  
  // If there are more surface patches than those in the NGF file, proceed with
  // structure translation of the surface patches not in the NGF file.
  if (m > m1) {
    
    // Index of the first patch that will be moved. Start with the patches
    // not in the NGF file.
	i1 = m1;
    
    // If nrpt is zero the move replaces the old patch data in the arrays.
    // Otherwise, add to the patch data.
    if (*nrpt == 0) {
      k = i1;
    }
    else {
      k = m;
      if (!NECDataBlockEnlargePatchBuffers(data, m + *nrpt * (m - i1 ))) {
        if (error_block != NULL) { *error_block = NECErrorMakeOutOfMemeory(); }
        return false;
      }
      if(!NECAngleBlockEnlargePatchBuffer(angl,  m + *nrpt * (m - i1 ))) {
        if (error_block != NULL) { *error_block = NECErrorMakeOutOfMemeory(); }
        return false; // Out of memory
      }
    }
    
    for (size_t it = 0; it < nrp; ++it) {  // Loop for each translation
      for (size_t ip = i1; ip < m; ++ip) { // Loop for each patch
        
        // Save the data to be moved in a separate variable since they may be
        // over written below.
        xi = xp[ip];
        yi = yp[ip];
        zi = zp[ip];
        
        // Perform the translation.
        xp[k] = xi * T11 + yi * T12 + zi * T13 + *xs;
        yp[k] = xi * T21 + yi * T22 + zi * T23 + *ys;
        zp[k] = xi * T31 + yi * T32 + zi * T33 + *zs;
        
        xi = t1x[ip];
        yi = t1y[ip];
        zi = t1z[ip];
        
        t1x[k] = xi * T11 + yi * T12 + zi * T13;
        t1y[k] = xi * T21 + yi * T22 + zi * T23;
        t1z[k] = xi * T31 + yi * T32 + zi * T33;
        
        xi = t2x[ip];
        yi = t2y[ip];
        zi = t2z[ip];
        
        t2x[k] = xi * T11 + yi * T12 + zi * T13;
        t2y[k] = xi * T21 + yi * T22 + zi * T23;
        t2z[k] = xi * T31 + yi * T32 + zi * T33;
        
        salp[k] = salp[ip];
        pa[k] = pa[ip];
        
        ++k; // Increment the index.
      }
      i1 = m;
      m = k;
    }
  }
  
  if (*nrpt == 0 && ix == 0) {
    // Keep symmetry.
  } else {
    // Remove all symmetry.
    np = n;
    mp = m;
    ipsym = 0;
  }
  
  return true;
}

#undef data_1 /* I don't like these... */
#undef x
#undef y
#undef z
#undef bi
#undef pa
#undef itag
#undef ld
#undef n1
#undef n2
#undef n
#undef np
#undef m1
#undef m2
#undef m
#undef mp
#undef ipsym
#undef salp
#undef x2
#undef y2
#undef z2
#undef t1x
#undef t1y
#undef t1z
#undef t2x
#undef t2y
#undef t2z
#undef xp
#undef yp
#undef zp
