//
//  reflec_2.c
//  ViperNEC
//
//  Created by Dylan Crocker on 8/14/14.
//  Copyright 2014 Viper Science
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#include "blocks.h"
#include "error.h"

#include <math.h>

// The below are used to keep the code shorter and prevent more massive code
// updating since the original version (translated by f2c) used these.
#define x (data->x)
#define y (data->y)
#define z (data->z)
#define xp (data->xp)
#define yp (data->yp)
#define zp (data->zp)
#define bi (data->bi)
#define pa (data->pa)
#define itag (data->itag)
#define ld (data->ld)
#define n1 (data->n1)
#define n2 (data->n2)
#define n (data->n)
#define np (data->np)
#define m1 (data->m1)
#define m2 (data->m2)
#define m (data->m)
#define mp (data->mp)
#define salp (angl->salp)
#define t1x (data->t1x)
#define t1y (data->t1y)
#define t1z (data->t1z)
#define t2x (data->t2x)
#define t2y (data->t2y)
#define t2z (data->t2z)
#define x2 (data->si)
#define y2 (data->alp)
#define z2 (data->bet)

/** This function (reflc_2) is a cleaned up version of the function generated by
 * f2c (reflc_) with some modifications. The main modification is the removal of
 * global data structures containing all the buffers to hold the geometry data.
 * Instead, the data objects (pointer) are passed as an input to the function.
 *
 * Original FORTRAN Summary:
 *     REFLC REFLECTS PARTIAL STRUCTURE ALONG X,Y, OR Z AXES OR ROTATES
 *     STRUCTURE TO COMPLETE A SYMMETRIC STRUCTURE.
 *
 * Original NEC Documentation:
 *
 * PURPOSE
 *     To generate geometry data for structures having plane or cylindrical
 * symmetry by forming symmetric images of a previously defined structure unit.
 *
 * METHOD
 *     The first part of the code, from statement RE20 to RE153, forms plane
 * symmetric structures by reflecting segments and patches in the coordinate
 * planes. The reflection planes are selected by the formal parameters IX, IY,
 * and IZ. If IZ is greater than zero, an image of the existing segments and
 * patches is formed by reflection in the x-y plane, which will be called
 * reflection along the z axis. Next, if IY is greater than zero, an image of
 * the existing segments and patches, including this generated in the previous
 * step by reflection along the z axis, is formed by reflection along the y
 * axis. Finally, if IX is greater than zero, an image of all segments and
 * patches, including any previously formed by reflection along the z and y
 * axes, is formed by reflection along the x axis. Any combination of zero and
 * non-zero values of IX, IY, and IZ may be used to generate structures with
 * one, two, or three planes of symmetry. Tag numbers of image segments are
 * incremented by ITX from tags of the original segments, except that tags of
 * zero are not incremented. After each reflection in a coordinate plane, ITX is
 * doubled. Thus, if ITX is initially greater than the largest tag of the
 * existing segments, no duplicate tags will be formed by reflection in one,
 * two, or three planes.
 *     The code from RE157 to RE204 forms cylindrically symmetric structures
 * by forming images of previously defined segments and patches rotated about
 * the z axis. The number of images, including the original structure, is
 * selected by NOP in the formal parameters. The angle by which each image is 
 * rotated about the z axis from the previous image is computed as 2*pi/NOP, so
 * that the images are uniformly distributed about the z axis. Tag numbers of 
 * segments are incremented by ITX, except that tags of zero are not 
 * incremented. 
 *     When REFLC is used to form structures with either plane or cylindrical
 * symmetry, the data in COMMON/DATA/ is set so that the program will take
 * advantage of symmetry in filling and factoring the matrix. This is done by
 * setting N equal to the total number of segments but leaving NP equal to the
 * number of segments in the original structure unit that was reflected or
 * rotated. The symmetry flag IPSYM is also set to indicate the type of
 * symmetry: positive values indicating plane symmetry and negative values
 * cylindrical symmetry. These symmetry conditions may later be changed if the
 * structure is modified in such a way that symmetry is destroyed.
 *
 * SYMBOL DICTIONARY
 *       ABS = external routine (absolute value)
 *       COS = external routine (cosine)
 *       CS = cos(2*pi/NOP)
 *       E1 = segment coordinate (temporary storage)
 *       E2 = segment coordinate (temporary storage)
 *       FNOP = NOP
 *       I = DO loop index
 *       ITAGI = segment tag (temporary storage)
 *       ITI = segment tag increment
 *       ITX = segment tag increment
 *       IX = flag for reflection along x axis
 *       IY = flag for reflection along y axis
 *       IZ = flag for reflection along z axis
 *       J = array location for new patch data
 *       K = segment index and array location for old patch data
 *       NOP = number of sections in cylindrically symmetric structure
 *       NX = segment index and array location for new patch data
 *       NNX = array location for old patch
 *       SAM = 2*pi/NOP
 *       SIN = external routine (sine)
 *       SS = sin(2*pi/NOP)
 *       T1X, T1X, T1Z = x, y, z components of t1 (vector)
 *       T2X, T2X, T2Z = x, y, z components of t2 (vector)
 *       XK = x coordinate of segment
 *       X2(I) = x coordinate of end two of segment I
 *       YK = y coordinate of segment
 *       Y2(I) = y coordinate of end two of segment I
 *       Z2(I) = z coordinate of end two of segment I
 *
 * CONSTANTS
 *       1.E-6 = tolerance in test for zero
 *       1.E-5 = tolerance in test for zero
 *       6.283185308 = 2*pi
 *
 * @param data NECDataBlock in which the parsed geometry data is stored. This
 * must not be NULL. The function will not execute if |data| is NULL.
 * @param angl NECAngleBlock in which is stored angle geometry information for
 * wires and patches (must not be NULL).
 * @param ix flag for reflection along x axis (if < 0 rotate to form cylinder).
 * @param iy flag for reflection along y axis.
 * @param iz flag for reflection along z axis.
 * @param itx The segment tag increment.
 * @param nop The number of sections in cylindrically symmetric structure.
 * @param error_block Pointer to a pointer of an NECError structure. If an error
 * occurs a new NECError is constructed and passed out by the pointer.
 * @return True if the reflection is completed successfully.
 * @since v1.0
 */
bool reflc_2(NECDataBlock *data, NECAngleBlock *angl, int *ix, int *iy,
             int *iz, int *itx, int *nop, NECError **error_block) {
  
  // If the data storage blocks are NULL then the function cannot proceed.
  if ((data == NULL) || (angl == NULL)) {
    if (error_block != NULL) { *error_block = NECErrorMakeInvalidInput(); }
    return false;
  }
  
  // If the number of symmetric sections is zero, return (nothing to do).
  if ((*ix < 0) && (*nop == 0)) { return true; }
  
  // Clear symmetry
  np = n;
  mp = m;
  data->ipsym = 0;
  
  long iti = *itx; // Save to another variable because this gets adjusted.
  
  //////////////////////////////////////////////////////////////////////////////
  //   REPRODUCE STRUCTURE WITH ROTATION TO FORM CYLINDRICAL STRUCTURE
  //////////////////////////////////////////////////////////////////////////////
  if (*ix < 0) {
    data->ipsym = -1; // Set symmetry flag to indicate cylindrical symmetry.
    
    double sam = 2 * M_PI / (*nop);
    double cs = cos(sam);
    double ss = sin(sam);
    
    // Variables used for temporary storage.
    double xk, yk;
    
    // If there are more wire segments than those in the NGF file, proceed with
    // structure rotation of the wire segments not in the NGF file.
    if (n > n1) {
      // Increase the wire segment count by the amount produced during rotation.
      n = n1 + (n - n1) * *nop;
      
      // Make sure the buffers are large enough.
      if (!NECDataBlockEnlargeWireBuffers(data, n) ||
          !NECAngleBlockEnlargeWireBuffer(angl, n)) {
        if (error_block != NULL) {
          *error_block = NECErrorMakeOutOfMemeory();
        }
        return false;
      }
      
      // Loop for each structure replecation creating the new wire segments.
      for (size_t i = np; i < n; ++i) {
        size_t k = i - np + n1;
        
        xk = x[k];
        yk = y[k];
        x[i] = xk * cs - yk * ss;
        y[i] = xk * ss + yk * cs;
        z[i] = z[k];
        
        xk = x2[k];
        yk = y2[k];
        x2[i] = xk * cs - yk * ss;
        y2[i] = xk * ss + yk * cs;
        z2[i] = z2[k];
        
        if (itag[k] == 0) { itag[i] = 0; }
        else { itag[i] = itag[k] + iti; }
        bi[i] = bi[k];
      }
    }
    
    // If there are more surface patchs than those in the NGF file, proceed...
    if (m > m1) {
      // Increase the surface patch count by the amount produced by rotation.
      m = m1 + (m - m1) * *nop;
      
      // Make sure the buffers are large enough.
      if (!NECDataBlockEnlargePatchBuffers(data, m) ||
          !NECAngleBlockEnlargePatchBuffer(angl, m)) {
        if (error_block != NULL) {
          *error_block = NECErrorMakeOutOfMemeory();
        }
        return false;
      }
      
      // Loop for each structure replecation creating the new surface patches.
      for (size_t i = mp; i < m; ++i) {
        size_t k = i - mp + m1;
        
        xk = xp[k];
        yk = yp[k];
        xp[i] = xk * cs - yk * ss;
        yp[i] = xk * ss + yk * cs;
        zp[i] = zp[k];
        
        xk = t1x[k];
        yk = t1y[k];
        t1x[i] = xk * cs - yk * ss;
        t1y[i] = xk * ss + yk * cs;
        t1z[i] = t1z[k];
        
        xk = t2x[k];
        yk = t2y[k];
        t2x[i] = xk * cs - yk * ss;
        t2y[i] = xk * ss + yk * cs;
        t2z[i] = t2z[k];
        
        salp[i] = salp[k];
        pa[i] = pa[k];
      }
    }
    
    // If the function was used to produce a cylindrical structure return here.
    return true;
  }
  
  data->ipsym = 1; // Set the symmetry flag for plane symmetry.
  
  //////////////////////////////////////////////////////////////////////////////
  //     REFLECT ALONG Z AXIS
  //////////////////////////////////////////////////////////////////////////////
  if (*iz > 0) {
    data->ipsym = 2; // plane symmetry about z = 0
    
    // Reflect wire segments.
    if (n > n1) {
      
      size_t old_n = n; // Save the old number of segments.
      n = (n * 2) - n1; // Update the number of segments.
      
      // Make sure the buffers are large enough.
      if (!NECDataBlockEnlargeWireBuffers(data, n) ||
          !NECAngleBlockEnlargeWireBuffer(angl, n)) {
        if (error_block != NULL) {
          *error_block = NECErrorMakeOutOfMemeory();
        }
        return false;
      }
      
      // Create the reflected wire segment structures.
      for (size_t si = n1; si < old_n; ++si) {
        size_t nx = si + old_n - n1;
        double e1 = z[si];
        double e2 = z2[si];
        if (((fabs(e1) + fabs(e2)) > 1e-5) && ((e1 * e2) >= -1e-6)) {
          x[nx] = x[si];
          y[nx] = y[si];
          z[nx] = -e1;
          x2[nx] = x2[si];
          y2[nx] = y2[si];
          z2[nx] = -e2;
          if (itag[si] == 0) { itag[nx] = 0; }
          else { itag[nx] = itag[si] + iti; }
          bi[nx] = bi[si];
        } else {
          // Error Occured - Segment found in the plane of symmetry.
          if (error_block != NULL) { *error_block = NECErrorMake023(si); }
          return false;
        }
      }
      iti *= 2;
    }
    
    // Reflect surface patches.
    if (m > m1) {
      
      size_t old_m = m; // Save the old number of patches.
      m = (m * 2) - m1; // Update the number of patches.
      
      // Make sure the buffers are large enough.
      if (!NECDataBlockEnlargePatchBuffers(data, m) ||
          !NECAngleBlockEnlargePatchBuffer(angl, m)) {
        if (error_block != NULL) {
          *error_block = NECErrorMakeOutOfMemeory();
        }
        return false;
      }
      
      // Create the reflected structures.
      for (size_t pn = m1; pn < old_m; ++pn) {
        size_t nx = pn + old_m - m1;
        if (fabs(zp[pn]) > 1e-10) {
          xp[nx] =  xp[pn];
          yp[nx] =  yp[pn];
          zp[nx] = -zp[pn];
          pa[nx] =  pa[pn];
          t1x[nx] =  t1x[pn];
          t1y[nx] =  t1y[pn];
          t1z[nx] = -t1z[pn];
          t2x[nx] =  t2x[pn];
          t2y[nx] =  t2y[pn];
          t2z[nx] = -t2z[pn];
          salp[nx] = -salp[pn];
        } else {
          // Error Occured - Patch found in the plane of symmetry.
          if (error_block != NULL) { *error_block = NECErrorMake020(pn); }
          return false;
        }
      }
    }
    
  } // End Z-axis reflection
  
  //////////////////////////////////////////////////////////////////////////////
  //     REFLECT ALONG Y AXIS
  //////////////////////////////////////////////////////////////////////////////
  if (*iy > 0) {
    
    // Reflect wire segments.
    if (n > n1) {
      
      size_t old_n = n; // Save the old number of segments.
      n = (n * 2) - n1; // Update the number of segments.
      
      // Make sure the buffers are large enough.
      if (!NECDataBlockEnlargeWireBuffers(data, n) ||
          !NECAngleBlockEnlargeWireBuffer(angl, n)) {
        if (error_block != NULL) {
          *error_block = NECErrorMakeOutOfMemeory();
        }
        return false;
      }
      
      // Create the reflected wire segment structures.
      for (size_t si = n1; si < old_n; ++si) {
        size_t nx = si + old_n - n1;
        double e1 = y[si];
        double e2 = y2[si];
        if (((fabs(e1) + fabs(e2)) > 1e-5) && ((e1 * e2) >= -1e-6)) {
          x[nx] = x[si];
          y[nx] = -e1;
          z[nx] = z[si];
          x2[nx] = x2[si];
          y2[nx] = -e2;
          z2[nx] = z2[si];
          if (itag[si] == 0) { itag[nx] = 0; }
          else { itag[nx] = itag[si] + iti; }
          bi[nx] = bi[si];
        } else {
          // Error Occured - Segment found in the plane of symmetry.
          if (error_block != NULL) { *error_block = NECErrorMake023(si); }
          return false;
        }
      }
      iti <<= 1;
    }
    
    // Reflect surface patches.
    if (m > m1) {
      
      size_t old_m = m; // Save the old number of patches.
      m = (m * 2) - m1; // Update the number of patches.
      
      // Make sure the buffers are large enough.
      if (!NECDataBlockEnlargePatchBuffers(data, m) ||
          !NECAngleBlockEnlargePatchBuffer(angl, m)) {
        if (error_block != NULL) {
          *error_block = NECErrorMakeOutOfMemeory();
        }
        return false;
      }
      
      // Create the reflected structures.
      for (size_t pn = m1; pn < old_m; ++pn) {
        size_t nx = pn + old_m - m1;
        if (fabs(yp[pn]) > 1e-10) {
          xp[nx] = xp[pn];
          yp[nx] = -yp[pn];
          zp[nx] = zp[pn];
          t1x[nx] = t1x[pn];
          t1y[nx] = -t1y[pn];
          t1z[nx] = t1z[pn];
          t2x[nx] = t2x[pn];
          t2y[nx] = -t2y[pn];
          t2z[nx] = t2z[pn];
          salp[nx] = -salp[pn];
          pa[nx] = pa[pn];
        } else {
          // Error Occured - Patch found in the plane of symmetry.
          if (error_block != NULL) { *error_block = NECErrorMake020(pn); }
          return false;
        }
      }
    }
    
  } // End Y-axis reflection
  
  //////////////////////////////////////////////////////////////////////////////
  //     REFLECT ALONG X AXIS
  //////////////////////////////////////////////////////////////////////////////
  if (*ix > 0) {
    
    // Reflect wire segments.
    if (n > n1) {
      
      size_t old_n = n; // Save the old number of segments.
      n = (n * 2) - n1; // Update the number of segments.
      
      // Make sure the buffers are large enough.
      if (!NECDataBlockEnlargeWireBuffers(data, n) ||
          !NECAngleBlockEnlargeWireBuffer(angl, n)) {
        if (error_block != NULL) {
          *error_block = NECErrorMakeOutOfMemeory();
        }
        return false;
      }
      
      // Create the reflected wire segment structures.
      for (size_t si = n1; si < old_n; ++si) {
        size_t nx = si + old_n - n1;
        double e1 = x[si];
        double e2 = x2[si];
        if (((fabs(e1) + fabs(e2)) > 1e-5) && ((e1 * e2) >= -1e-6)) {
          x[nx] = -e1;
          y[nx] = y[si];
          z[nx] = z[si];
          x2[nx] = -e2;
          y2[nx] = y2[si];
          z2[nx] = z2[si];
          if (itag[si] == 0) { itag[nx] = 0; }
          else { itag[nx] = itag[si] + iti; }
          bi[nx] = bi[si];
        } else {
          // Error Occured - Segment found in the plane of symmetry.
          if (error_block != NULL) { *error_block = NECErrorMake023(si); }
          return false;
        }
      }
    }
    
    // Reflect surface patches.
    if (m > m1) {
      
      size_t old_m = m; // Save the old number of patches.
      m = (m * 2) - m1; // Update the number of patches.
      
      // Make sure the buffers are large enough.
      if (!NECDataBlockEnlargePatchBuffers(data, m) ||
          !NECAngleBlockEnlargePatchBuffer(angl, m)) {
        if (error_block != NULL) {
          *error_block = NECErrorMakeOutOfMemeory();
        }
        return false;
      }
      
      // Create the reflected structures.
      for (size_t pn = m1; pn < old_m; ++pn) {
        size_t nx = pn + old_m - m1;
        if (fabs(xp[pn]) > 1e-10) {
          xp[nx] = -xp[pn];
          yp[nx] = yp[pn];
          zp[nx] = zp[pn];
          t1x[nx] = -t1x[pn];
          t1y[nx] = t1y[pn];
          t1z[nx] = t1z[pn];
          t2x[nx] = -t2x[pn];
          t2y[nx] = t2y[pn];
          t2z[nx] = t2z[pn];
          salp[nx] = -salp[pn];
          pa[nx] = pa[pn];
        } else {
          // Error Occured - Patch found in the plane of symmetry.
          if (error_block != NULL) { *error_block = NECErrorMake020(pn); }
          return false;
        }
      }
    }
    
  } // End X-axis reflection

  return true;
}

#undef x
#undef y
#undef z
#undef xp
#undef yp
#undef zp
#undef bi
#undef itag
#undef ld
#undef n1
#undef n2
#undef n
#undef np
#undef m1
#undef m2
#undef m
#undef mp
#undef salp
#undef t1x
#undef t1y
#undef t1z
#undef t2x
#undef t2y
#undef t2z
#undef x2
#undef y2
#undef z2
