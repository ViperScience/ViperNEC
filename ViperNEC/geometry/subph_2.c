//
//  subph_2.c
//  ViperNEC
//
//  Created by Dylan Crocker on 10/29/14.
//  Copyright 2014 Viper Science
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#include "const.h"
#include "blocks.h"
#include "error.h"

#include <math.h>

/**
 * subph_2
 * This function divides patches for connections to wires. This function is a 
 * cleaned up version of the function generated by f2c with some modifications. 
 * The main modification is the removal of global data structures containing all
 * the buffers to hold the geometry data. Instead, the data object (pointer) is 
 * passed as an input to the function. Additionally, in the original FORTRAN 
 * code this was a single subroutine with multiple entry points (PATCH and 
 * SUBPH). These entry points have been made into two separate functions 
 * residing in separate files.
 *
 * Original Documentation from PATCH:
 * The code from PA131 to PA190 divides a patch into four patches and is
 * used when a wire connects to a patch. If NY is equal to zero, the patch NX is
 * divided into four patches that become patches NX through NX + 3. Patches
 * following NX are shifted in the arrays in COMMON/DATA/ to leave space for the
 * three additional patches. If NY is greater than zero, patch NX is left in the
 * arrays but four new patches to replace it are added to the end of the arrays.
 * The z coordinate of patch NX is then changed tn 10,000 At PA189.
 *
 * @param data NECDataBlock in which the parsed geometry data is stored. This
 *             must not be NULL. The function will not execute if |data| is
 *             NULL (return an error).
 * @param angl NECAngleBlock in which is stored angle geometry information for
 *             wires and patches (must not be NULL).
 * @param nx The index of the patch to be divided.
 * @param ny If ny is 0, the origianl patch is replaced by for new patches
 *           (other data shifted up to make room for new patches). If ny > 0 
 *           keep the old patch in the array. Start adding new patches at the
 *           end of the buffer. The old patch is left in the array, but moved
 *           outside the solution space (where it will have no effect).
 * @return Returns TRUE if the function completed successfully.
 * @since v1.0
 */
bool subph_2(NECDataBlock *data, NECAngleBlock *angl, size_t nx, int ny,
             NECError **error_block) {
  
  // Check the inputs.
  if (!data || !angl) {
    if (error_block != NULL) { *error_block = NECErrorMakeInvalidInput(); }
    return false;
  }
  
  // Split the specified patch into 4 sub patches.
  
  size_t s_index = nx; // Index of patch to split
  
  // If ny == 0 (replace the patch specified by nx with 4 new patches) and
  // nx < m (at the end of the array) shift the contents of the array up to
  // make room for the new patches.
  if ((ny == 0) && (s_index < data->m)) {
    
    // Start at the top of the array and move down.
    size_t top_index = (data->m - 1); // patches count - 1
    
    // Make sure buffer is big enough...
    bool resize = NECDataBlockEnlargePatchBuffers(data, top_index + 4) &&
                  NECAngleBlockEnlargePatchBuffer(angl, top_index + 4);
    if (!resize) {
      if (error_block) { *error_block = NECErrorMakeOutOfMemeory(); }
      return false;
    }
    
    for (size_t move_index = top_index; move_index > s_index; move_index--) {
      data->xp[move_index + 3] = data->xp[move_index];
      data->yp[move_index + 3] = data->yp[move_index];
      data->zp[move_index + 3] = data->zp[move_index];
      data->pa[move_index + 3] = data->pa[move_index];
      data->t1x[move_index + 3] = data->t1x[move_index];
      data->t1y[move_index + 3] = data->t1y[move_index];
      data->t1z[move_index + 3] = data->t1z[move_index];
      data->t2x[move_index + 3] = data->t2x[move_index];
      data->t2y[move_index + 3] = data->t2y[move_index];
      data->t2z[move_index + 3] = data->t2z[move_index];
      angl->salp[move_index + 3] = angl->salp[move_index];
    }
  }
  
  // Get all the info on the patch to split.
  double xs = data->xp[s_index];
  double ys = data->yp[s_index];
  double zs = data->zp[s_index];
  double xa = data->pa[s_index] * 0.25;
  double xst = sqrt(xa) * 0.5;
  double s1x = data->t1x[s_index];
  double s1y = data->t1y[s_index];
  double s1z = data->t1z[s_index];
  double s2x = data->t2x[s_index];
  double s2y = data->t2y[s_index];
  double s2z = data->t2z[s_index];
  double xt = xst;
  double yt = xst;
  double saln = angl->salp[s_index]; // Temp store value from SALP
  
  // If ny > 0 keep the old patch in the array. Start adding new patches at
  // the end of the buffer. Otherwise, insert the new patches in the buffer
  // starting at the specified patch.
  size_t mia = s_index;
  if (ny > 0) {
    ++(data->m);
    ++(data->mp);
    mia = data->m - 1;
  }
  
  // If we are adding to the end of the buffers ensure the buffers are large
  // enough to hold the additional data.
  if ((ny > 0) || (nx == data->m)) {
    if (!NECDataBlockEnlargeWireBuffers(data, mia + 1)) {
      if (error_block) { *error_block = NECErrorMakeOutOfMemeory(); }
      return false;
    }
    if(!NECAngleBlockEnlargePatchBuffer(angl, mia + 1)) {
      if (error_block) { *error_block = NECErrorMakeOutOfMemeory(); }
      return false; // Out of memory
    }
  }
  
  for (int ix = 1; ix <= 4; ++ix) {
    
    data->xp[mia] = xs + xt * s1x + yt * s2x;
    data->yp[mia] = ys + xt * s1y + yt * s2y;
    data->zp[mia] = zs + xt * s1z + yt * s2z;
    data->pa[mia] = xa;
    data->t1x[mia] = s1x;
    data->t1y[mia] = s1y;
    data->t1z[mia] = s1z;
    data->t2x[mia] = s2x;
    data->t2y[mia] = s2y;
    data->t2z[mia] = s2z;
    angl->salp[mia] = saln;
    
    if (ix == 2) { yt = -yt; }
    if (ix == 1 || ix == 3) { xt = -xt; }
    
    ++mia;
  }
  
  // Increment the patch count.
  data->m += 3;
  if (nx <= data->mp) { data->mp += 3; }
  
  // If the old patch was left in the array, move it outside the solution
  // space (where it will have no effect).
  if (ny > 0) { data->zp[s_index] = NEC_OUT_OF_SOLUTION_OFFSET; }
  
  return true;
}