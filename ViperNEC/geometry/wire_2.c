//
//  wire_2.c
//  ViperNEC
//
//  Created by Dylan Crocker on 7/18/14.
//  Copyright 2014 Viper Science
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#include "blocks.h"
#include "error.h"

#include <stdbool.h>
#include <stdlib.h>
#include <math.h>

// The code uses these arrarys to store some other stuff temporarily.
#define x2 data->si
#define y2 data->alp
#define z2 data->bet

/**
 * This function (wire_2) is a cleaned up version of the function generated by
 * f2c (wire_) with some modifications. The main modification is the removal of
 * a global data structure containing all the buffers to hold the geometry data.
 * Instead, the data object (pointer) is passed as an input to the function.
 *
 * Original FORTRAN Summary:
 * SUBROUTINE WIRE GENERATES SEGMENT GEOMETRY DATA FOR A STRAIGHT WIRE OF NS 
 * SEGMENTS.
 *
 * Original NEC Documentation:
 *
 * PURPOSE:
 *     To comput segment coordinates to fill COMMONO/DATA/ for a strait line of
 * segments.
 *
 * METHOD
 *     The formal parameters specify the beginnig and ending points of the line
 * and the number of segments into which it is to be divided. The code computes
 * the coordinates of the end points of each segment. The lengths of successive
 * segments are scaled by the factor RDKL if this factor is not one.
 *
 * For NS segments, the length of the first segment is
 * 
 *               S1 = L(I - RDEL)/(1 - (RDEL^NS)
 *
 * or            S1 = L/NS if RDEL = 1
 *
 * where L is the total length of the wire.
 * The radius is RAD for the first segment and is scaled by RRAD.
 *
 * @param data NECDataBlock in which the parsed geometry data is stored. This
 * must not be NULL. The function will not execute if |data| is NULL.
 * @param xw1
 * @param yw1
 * @param zw1
 * @param xw1
 * @param xw2
 * @param yw2
 * @param zw2
 * @param rad
 * @param rdel
 * @param rrad
 * @param itg The tag number assigned to each segment.
 * @param ns The number of segments.
 * @param error_block This is an output variable (pointer to a pointer) that
 *        will contain information regaurding any errors that occur.
 * @return Logical 1 (true) if function completed without errors, 0 otherwise.
 * @since v1.0
 */
bool wire_2(NECDataBlock *data, double *xw1, double *yw1,
            double *zw1, double *xw2, double *yw2,
            double *zw2, double *rad, double *rdel,
            double *rrad, int *ns, int *itg,
            NECError **error_block) {
  
  // Check the inputs.
  if (data == NULL) {
    if (error_block != NULL) { *error_block = NECErrorMakeInvalidInput(); }
    return false;
  }
  if (*ns < 1) { return true; /* no segments?? */ }
  
  size_t index_start = data->n; // I think this may be off by one...
  data->n += *ns;
  data->np = data->n;
  data->mp = data->m;
  data->ipsym = 0;
  
  // Make sure the buffers are large enough.
  if (NECDataBlockEnlargeWireBuffers(data, data->n) == false) {
    if (error_block != NULL) { *error_block = NECErrorMakeOutOfMemeory(); }
    return false;
  }
  
  double rd;                        // Scaling factor for segment length
  double xs1 = *xw1;                // x coordinate of first end of segment
  double ys1 = *yw1;                // y coordiante of first end of segment
  double zs1 = *zw1;                // z coordiante of first end of segment
  double xs2;                       // x coordiante of second end of segment
  double ys2;                       // y coordiante of second end of segment
  double zs2;                       // z coordiante of second end of segment
  double delz;                      // segment length
  double radz = *rad;               // segment radius
  double fns = (double) (*ns);  // real number equivalent of NS
  double xd = *xw2 - *xw1;          // increment to x coordinate
  double yd = *yw2 - *yw1;          // increment to y coordinate
  double zd = *zw2 - *zw1;          // increment to z coordinate
  
  if (fabs(*rdel - 1.0) < 1e-6) {
    xd /= fns;
    yd /= fns;
    zd /= fns;
    delz = 1.f;
    rd = 1.f;
  } else {
    delz = sqrt(xd*xd + yd*yd + zd*zd);
    xd /= delz;
    yd /= delz;
    zd /= delz;
    delz = delz*(1.f - *rdel) / (1.f - pow(*rdel, fns));
    rd = *rdel;
  }
  
  for (size_t index = index_start; index < data->n; ++index) {
    data->itag[index] = *itg;
    
    // Calculate the end of the current segment.
    xs2 = xs1 + xd * delz;
    ys2 = ys1 + yd * delz;
    zs2 = zs1 + zd * delz;
    
    // Store the beginning and end segment coordinates.
    data->x[index] = xs1;
    data->y[index] = ys1;
    data->z[index] = zs1;
    x2[index] = xs2;
    y2[index] = ys2;
    z2[index] = zs2;
    
    data->bi[index] = radz;
    
    delz *= rd;    // Scale the length increment (for the next segment)
    radz *= *rrad; // Scale the radius (for the next segment)
    
    // Set the beginning of the next segment to the end of the current segment.
    xs1 = xs2;
    ys1 = ys2;
    zs1 = zs2;
  }
  
  x2[data->n - 1] = *xw2;
  y2[data->n - 1] = *yw2;
  z2[data->n - 1] = *zw2;
  
  return true;
}

#undef x2
#undef y2
#undef z2
